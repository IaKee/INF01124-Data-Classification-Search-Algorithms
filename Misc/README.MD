This folder contains several algorithms I developed while studying the INF01124 Data Classification and Search Algorithms course at UFRGS. The algorithms implemented in Python include:

- `bubblesort.py`: Implementation of the bubble sort algorithm, which repeatedly swaps adjacent elements if they are in the wrong order. This algorithm has a time complexity of O(n^2).
- `selectionsort.py`: Implementation of the selection sort algorithm, which sorts an array by repeatedly finding the minimum element from the unsorted part of the array and putting it at the beginning. This algorithm has a time complexity of O(n^2).
- `insertionsort.py` and `insertionsort2.py`: Two implementations of the insertion sort algorithm, which builds the final sorted array one item at a time by comparing each new item with the already sorted part of the array and inserting it in the correct position. Both implementations have a time complexity of O(n^2).
- `shellsort.py`: Implementation of the shell sort algorithm, which is an extension of the insertion sort algorithm that compares elements separated by a gap of several positions. This algorithm has a time complexity of O(n log n).
- `mergesort.py`: Implementation of the merge sort algorithm, which divides the unsorted list into n sublists, each containing one element, and repeatedly merges sublists to produce new sorted sublists until there is only one sublist remaining. This algorithm has a time complexity of O(n log n).
- `quicksortLomuto.py` and `quicksortHoare.py`: Two implementations of the quicksort algorithm, which is a divide-and-conquer algorithm that selects a "pivot" element from the array and partitions the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The two implementations differ in the way they choose the pivot element. The Lomuto partition scheme is simpler but less efficient, while the Hoare partition scheme is more efficient but more complex. Both implementations have an average time complexity of O(n log n).
- `heapsort.py`: Implementation of the heapsort algorithm, which uses a binary heap data structure to sort an array. The binary heap is first built from the array, then repeatedly extracts the maximum element from the heap and places it at the end of the array. This algorithm has a time complexity of O(n log n).
- `radixLSD.py`: Implementation of the radix sort algorithm, which sorts data with integer keys by grouping the keys by individual digits that share the same significant position and value. This algorithm has a time complexity of O(kn), where k is the number of digits in the longest number.
- `d.py`: This file contains a simple implementation of the binary search algorithm, which searches for a specific element in a sorted array by repeatedly dividing the search interval in half. The algorithm has a time complexity of O(log n).